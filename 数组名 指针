首先，声明一个数组和一个常量指针并指向那个数组。

1     int arr[3] = { 1, 2, 3 };      //声明数组
2     const int *p_arr = arr;        //声明常量指针
 

设问：一个整型指针的长度为4Byte，比较数组名的数据长度和指针的数据长度是否相等？

printf("*p_arr的长度=%d，arr的长度=%d\n", sizeof(p_arr),sizeof(arr));
运行结果：p_arr的长度=4，arr的长度=12

结论：数组名应该不是指针。

 

设问：数组名不能作为左值，那常量指针呢？

p_arr = p_arr;
运行结果：不报错

arr = arr;
运行结果：报错——“=”做操作数必须左值 and 表达式必须是可修改的左值。

const int *p_arr = &arr[0]; //重新声明一个，指向数组首地址 
printf("p_arr的地址=%p，arr的地址=%p\n", &p_arr, &arr);
运行结果：p_arr的地址=002DF958，arr的地址=002DF964。

结论：数组名不是常量指针，更不是指向数组首地址的常量指针。

 

设问：常量指针能为左值，那常量呢？

1     const int a = 3;
2     a = a;
运行结果：报错——“a”不能给常量赋值 and 表达式必须是可修改的左值。

结论：常量指针不是一个常量。

 

设问：数组名是一个常量吗？

printf("3的地址=%p，arr的地址=%p\n", &3, &arr);
运行结果：报错——常量上的“&” and 表达式必须为左值或者函数提示符。（数组名存在地址，而常量不存在）

#define B 5
printf("B的地址=%p，arr的地址=%p\n", &B, &arr);
运行结果：报错——常量上的“&” and 表达式必须为左值或者函数提示符。（与上一致）

printf("a的地址=%p，arr的地址=%p\n", &a, &arr); //a是之前用const声明过的常量
运行结果：能正常运行，说明a和arr都有自己的存储空间。

1     a = arr[0]; //因为arr=arr[0],现在那arr[0]的值赋给a
2     printf("a的地址=%p，arr的地址=%p\n", &a, &arr);
运行结果：a的地址=0041F7FC，arr的地址=0041F814（二者不在同一块内存单元中）

结论：数组名不是一个常量，也不是一个用const限定变量所形成的常量。

 

设问：数组名是否完成等同于数组首地址？

&arr[0] = &arr[0];
运行结果：报错——“=”做操作数必须左值 and 表达式必须是可修改的左值。（和arr = arr;的结果一致）

printf("arr[0]的地址=%p，arr的地址=%p\n", &arr[0], &arr);
运行结果：arr[0]的地址=002FFA34，arr的地址=002FFA34。（地址完全相等）

printf("&arr的长度=%d，arr的长度=%d\n", sizeof(&arr[0]), sizeof(arr));
运行结果：&arr的长度=4，arr的长度=12。

结论：数组名应该就是数组首地址，只是当在使用sizeof运算符时，可能进行了隐式转换。（转换指代整个数组，既sizeof(arr)=数组中元素的个数 乘以 sizeof(arr[0])的值）

 

最后的结论：暂且认为数组名在一般情况下就是该数组的首地址，在使用sizeof运算符时，数组名指代自身数组的全部元素的地址。
