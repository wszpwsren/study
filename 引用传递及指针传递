1. 概念

　　指针从本质上讲是一个变量，变量的值是另一个变量的地址，指针在逻辑上是独立的，它可以被改变的，包括指针变量的值（所指向的地址）和指针变量的值对应的内存中的数据（所指向地址中所存放的数据）。

　　引用从本质上讲是一个别名，是另一个变量的同义词，它在逻辑上不是独立的，它的存在具有依附性，所以引用必须在一开始就被初始化（先有这个变量，这个实物，这个实物才能有别名），而且其引用的对象在其整个生命周期中不能被改变，即自始至终只能依附于同一个变量（初始化的时候代表的是谁的别名，就一直是谁的别名，不能变）。

 

2. C++中的指针参数传递和引用参数传递

　　指针参数传递本质上是值传递，它所传递的是一个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。

　　引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。

　　引用传递和指针传递是不同的，虽然他们都是在被调函数栈空间上的一个局部变量，但是任何对于引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。而对于指针传递的参数，如果改变被调函数中的指针地址，它将应用不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使用指向指针的指针或者指针引用。

　　从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名及变量所对应地址。指针变量在符号表上对应的地址值为指针变量的地址值，而引用在符号表上对应的地址值为引用对象的地址值（与实参名字不同，地址相同）。符号表生成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），而引用对象则不能修改。

3. 总结

相同点：

　　都是地址的概念

不同点：

　　指针是一个实体（替身）；引用只是一个别名（本体的另一个名字）

　　引用只能在定义时被初始化一次，之后不可改变，即“从一而终”；指针可以修改，即“见异思迁”；

　　引用不能为空（有本体，才有别名）；指针可以为空；

　　sizeof 引用，得到的是所指向变量的大小；sizeof 指针，得到的是指针的大小；

　　指针 ++，是指指针的地址自增；引用++是指所指变量自增；

　　引用是类型安全的，引用过程会进行类型检查；指针不会进行安全检查；

1. 值传递 

复制代码
 1 void f( int  p){
 2     printf("\n%x",&p);
 3     printf("\n%x",p);
 4     p=0xff;
 5 }
 6 void main()
 7 {
 8     int a=0x10;
 9     printf("\n%x",&a);
10     printf("\n%x\n",a);
11     f(a);
12     printf("\n%x\n",a);
13 }
复制代码


通过上例我们可以看到，int a=0x10，存放的地址为0x12ff44，值为10，当调用f(a)时，传递给p的值为10，但是p的地址为0x12fef4，当改变p=0xff，时是改变地址为0x12fef4中的内容，并没有改变0x12ff44中的内容，所以调用f(a)，后a的值仍然为0x10，所以值传递无法改变变量的值。示意图如下：



2. 引用传递

复制代码
 1 void f( int & p){
 2     printf("\n%x",&p);
 3     printf("\n%x",p);
 4     p=0xff;
 5 }
 6 void main()
 7 {
 8     int a=0x10;
 9     printf("\n%x",&a);
10     printf("\n%x\n",a);
11     f(a);
12     printf("\n%x\n",a);
13 }
复制代码


通过上面引用传递传递案例我们可以看到，调用f(a)时，传递给p的是a的地址，所以p和a的地址都是0X12ff44，所以p就是a，改变p当然能改变a。示意图如下：



3. 指针传递

复制代码
 1 void f( int*p){
 2     printf("\n%x",&p);
 3     printf("\n%x",p);
 4     printf("\n%x\n",*p);
 5     *p=0xff;
 6 }
 7 void main()
 8 {
 9     int a=0x10;
10     printf("\n%x",&a);
11     printf("\n%x\n",a);
12     f(&a);
13     printf("\n%x\n",a);
14 }
复制代码


通过指针传递的案例我们可以看到，调用f(&a)是将a的地址0x12ff44传递给p，则*p就指向了a的内容，改变*p后，a的内容自然就改变了，示意图如下：



4. 指针的引用传递

复制代码
 1 void f( int*&p){
 2     printf("\n%x",&p);
 3     printf("\n%x",p);
 4     printf("\n%x\n",*p);
 5     *p=0xff;
 6 }
 7 void main()
 8 {
 9     int a=0x10;
10     printf("\n%x",&a);
11     printf("\n%x\n",a);
12     int *b=&a;
13     printf("\n%x",&b);
14     printf("\n%x",b);
15     printf("\n%x\n",*b);
16     f(b);
17     printf("\n%x\n",a);
18 }
复制代码


为了使用指针的引用传递我们要新建一个指针b，然后将b的引用传递给p，其实p就是b的一个拷贝，*p=*b都指向a，所以改变*p的内容也就改变a的内容。示意图如下：



我们再来看一下如果不用指针的引用传递会出现什么结果

复制代码
 1 void f( int*p){
 2     printf("\n%x",&p);
 3     printf("\n%x",p);
 4     printf("\n%x\n",*p);
 5     *p=0xff;
 6 }
 7 void main()
 8 {
 9     int a=0x10;
10     printf("\n%x",&a);
11     printf("\n%x\n",a);
12     int *b=&a;
13     printf("\n%x",&b);
14     printf("\n%x",b);
15     printf("\n%x\n",*b);
16     f(b);
17     printf("\n%x\n",a);
18     printf("\n%x\n",b);
19 }
复制代码


从结果中我们可以看到调用f(b)时，传递给p的是b的内容，但是&b，和&p是不一样的，虽然*p和*b都指向a。示意图如下：



 



作者： ZH奶酪——张贺 
Q Q： 1203456195 
邮箱： cheesezh@qq.com 
出处： http://www.cnblogs.com/CheeseZH/ 
* 本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接，否则保留追究法律责任的权利。
